# README.txt
#
# SNDlib API distribution (http://sndlib.zib.de)
#
# Copyright (c) 2005-2006 by Konrad-Zuse-Zentrum fuer Informationstechnik Berlin. 
# (http://www.zib.de)  
#

Contents:
---------

(i)   License
(ii)  Requirements
(iii) Contents of this distribution
(iv)  Using SNDlib API


-----------
(i) License
-----------

The SNDlib API is licensed under the ZIB ACADEMIC LICENSE; you may not use 
this distribution except in compliance with the License. You may obtain a 
copy of the License at

        http://www.zib.de/Optimization/Software/ziblicense.html

as well as in the file LICENSE.txt, contained in this distribution.

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations 
under the License.


-----------------
(ii) Requirements
-----------------

The SNDlib API is implemented in Java-5.0. Hence you need an installed 
JDK/JRE 5.0 in order to use the API.


-----------------------------------
(iii) Contents of this distribution 
-----------------------------------

This distribution includes:

./src/

        This folder contains the Java source files.

---

./lib/

        This folder contains the required libraries related to 
        XML parsing, validating and serializing. In detail:

./lib/xml-apis.jar

        The common XML-APIs (javax.xml, org.w3c, org.xml)

./lib/xerces-<version>.jar

        Implements javax.xml.parsers.SAXParserFactory and 
        javax.xml.validation.SchemaFactory.
        
        It is used to parse and validate XML documents.

./lib/xalan-<version>.jar
./lib/xml-serializer-<version>.jar

        Implements javax.xml.transform.sax.SAXTransformerFactory.
        
        It is used to write XML files.

./lib/castor-<version>-xml.jar

        Castor can generate Java classes from XML schemas. The generated Java 
        classes corresponding to network.xsd, model.xsd and solution.xsd are 
        contained in ./lib/sndlib-castorgen.jar, see below.
        
        In this distribution it is used to unmarshal XML documents to Java 
        objects and vice versa. 
        
        Using Castor provides a very elegant way to deal with XML files. For 
        further details on Castor please visit (http://www.castor.org).
        
./lib/sndlib-castorgen.jar

        The Java classes corresponding to the XML schemas (network.xsd, 
        model.xsd, solution.xsd), generated by Castor. 
        
        The XML schemas you will find in ./src/sndlib/io/xml.

./lib/commons-logging.jar

        This logging library is used by Exolab Castor. It represents a switch 
        between the java logging framework java.util.logging and the mightful 
        opensource implementation org.apache.log4j.
        
./lib/jakarta-oro-<version>.jar

        This library is used by Exolab Castor for dealing with regular 
        expressions within the XML schema definitions.
        
./lib/atesio-java-utils-<version>.jar

        Collects some utility classes.
	
./lib/atesio-gml-writer-<version>.jar

        Base library for constructing and writing GML files.
	    
./lib/javaproj.jar

        Library used by atesio-gml-writer-<version>.jar to project geographical 
        coordinates (longitude/latitude) to plane, i.e. convert them to screen
        coordinates.

---

./docu/api

        Contains the generated Java documentation.

./docu/io-formats
        
        Contains the documentation of the I/O formats used 
        in SNDlib (native, XML). You will find this documentation 
        on the SNDlib webpage (http://sndlib.zib.de) as well.
        
---

./sndlib.jar

        Contains the compiled Java classes (compiled from ./src/).
        
./LICENSE.txt

        The license under which the SNDlib API is distributed (see (i)).


---------------------
(iv) Using SNDlib API
---------------------

The SNDlib API consists of the following packages:

-sndlib.core

        Contains the core functionality of SNDlib. In detail:

-sndlib.core.network, sndlib.core.model, sndlib.core.solution

        Contains the basic data structures for Network, Model and Solution.

-sndlib.core.problem

        Contains advanced data structures. The main classes are 
        
        (1) Problem       which couples a Network with a Model
        (2) SolvedProblem which is used to apply a specific Solution to a Problem.

-sndlib.core.validation

        Contains classes to check Problems and Solutions for feasibility.
        
-sndlib.core.statistics

        Contains classes to generate statistics on Problems and Solutions.

-sndlib.core.util

        Contains some utility classes.
        
-sndlib.core.io
        
        Contains the SNDlib I/O interface.

-sndlib.core.io.native, sndlib.core.io.xml

        Contains the I/O implementations for the native and XML format.
        
-sndlib.ext.generators.gml

        Contains classes to generate GML files for Problems and Solutions.

---

Using the SNDlib API is simple. First make sure that all libraries 
(./lib/*.jar) including ./sndlib.jar are on the java classpath.

If all is prepared to get start try out these examples:


I. Parsing and writing SNDlib objects (Network, Model, Solution)
-----------------------------

<code>
   Reader networkReader = new FileReader("path/to/a/network/file");
   Reader modelReader = new FileReader("path/to/a/model/file");
   
   // get the appropriate parser, e.g. for the native format
   SNDlibParser parser = SNDlibIOFactory.newParser(SNDlibIOFormat.NATIVE);
   
   Network network = null;
   Model model = null;
   try {
      network = parser.parseNetwork(networkReader);
      model = parser.parseModel(modelReader);
   }
   catch(SNDlibParseException spx) {
      System.err.println("could not parse network or model file: " + spx);
   }
           
   // get the appropriate writer, e.g. for the native format
   SNDlibWriter writer = SNDlibIOFactory.newWriter(SNDlibIOFormat.NATIVE);
           
   Writer networkWriter =  new FileWriter("path/network.txt");
   Writer modelWriter = new FileWriter("path/model.txt");
   try {
      writer.writeNetwork(network, networkWriter);
      writer.writeModel(model, modelWriter);
      networkWriter.close();
      modelWriter.close();
   }
   catch(SNDlibWriteException swx) {
      System.err.println("could not write network or model file: " + spx);
   }
</code>

II. Parsing dynamic matrices
-----------------------------
A single demand matrix is just a Network object without links
(empty link section). To parse a set of single matrices just use 
the Network parser as shown above.

Dynamic matrices contain a special Meta section with additional information
(Every Network object can have such an optional Meta section with information
about the demands). The Meta section specifies:

- granularity  ... over which time horizon has the data been averaged, e.g. 5 minutes, 15 minutes, 1 day
- time         ... a time stamp
- origin       ... origin of the data
- unit         ... unit of the data, e.g. Mbits or Gbits


III. Check a Problem and a Solution for feasibility
-----------------------------

<code>
   // get a Problem
   Problem problem = parseProblem();
   
   Messages errors = ProblemValidators.validateAll(problem);
   if(errors.size() > 0) {
      System.err.println("Problem is not feasible:\n" + errors);
   }
           
   // get a Solution
   Solution solution = parseSolution();
           
   // apply the Solution to the Problem by constructing a SolvedProblem
   SolvedProblem solvedProblem = new SolvedProblem(problem, solution);
           
   // check Solution and Problem for consistency
   errors = solvedProblem.checkConsistency();
   if(errors.size() > 0) {
      System.err.println("Solution is not consistent with the problem:\n" 
      + errors);
   }
                                   
   // check Solution for feasibility
   errors = SolutionValidators.validateAll(solvedProblem);
   if(errors.size() > 0) {
      System.err.println("Solution is not feasible:\n" + errors);
   }
</code>


IV. Generate statistics of a Problem and a Solution
-----------------------------

<code>
   // get a Problem
   Problem problem = parseProblem();
           
   // generate statistics on the Problem
   ProblemStatistics probStats = ProblemStatistics.newStatistics(problem);
   System.out.println("Statistics for the problem:\n" + probStats);
           
   // get a Solution
   Solution solution = parseSolution();
           
   // apply the solution to the problem
   SolvedProblem solvedProblem = new SolvedProblem(problem, solution);
           
   // generate statistics of the Solution
   SolutionStatistics 
      solStats = SolutionStatistics.newStatistics(solvedProblem);
   System.out.println("Statistics for the solution:\n" + solStats);
</code>  
        
        
Note, that the feasibility checks as well as the statistic generation can be
adapted to your own needs. 
For example, imagine you would like to have an additional statistic value 
telling you the ratio of the number of nodes and links in a network. You 
could write, e.g., code like this:

<code>
   // first implement the desired statistic value as mentioned above
   public class MyProblemStatisticValueKey 
      implements ProblemStatisticValueKey {
           
      public double calculateValue(Problem problem) {
          return (double)problem.nodeCount() / (double)problem.linkCount();
      }
              
      public String getName() {
          return "RATIO_NODES_LINKS";
      }
   }
           
   // then write your statistics class in this kind        
   public class MyProblemStatistics {
   
      public static ProblemStatistics newStatistics(Problem problem) {

         Set<ProblemStatisticValueKey> 
            keys = new HashSet<ProblemStatisticValueKey>();
                   
         // add the SNDlib build-in statistic keys
         keys.addAll(EnumSet.allOf(ProblemStatisticValueKeys.class));
                   
         // add your own statistic key
         keys.add(new MyProblemStatisticValueKey());
   
         return ProblemStatistics.newStatistics(problem, keys);
      }               
   }
</code>

V. Generate GML for Problem/Solution
-------------------------------------

<code>
   // get a Problem
   Problem problem = parseProblem();
   
   // get default gml properties as defined in gml.properties
   SNDlibGmlProperties gmlProps = SNDlibGmlProperties.getDefaults();
   
   // or load individual properties
   gmlProps.load(new FileInputStream("path/to/my.gml.properties"));
   
   // get a target stream
   OutputStream gmlTarget = getTarget();
   
   // generate problem gml
   SNDlibGmlGenerator.generateProblemGml(problem, target);
</code>

The code for generating a GML for a Solution looks quite similar. 

-----------

For further questions regarding the API please visit the SNDlib webpage 
(http://sndlib.zib.de), subscribe to the mailing list and/or send an email
to the SNDlib webmaster.


Thank you


#End README.txt
